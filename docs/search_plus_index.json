{"./":{"url":"./","title":"はじめに","keywords":"","body":"Python×Djangoの実践スキルを学ぼう！～CSVデータの自動取込をやってみよう！～​ 事前準備 VSCodeインストール Dockerインストール Gitインストール、GitHubアカウントの作成 今回の流れ（登録画面の実装 ～ バッチ処理の自動化） Djangoフレームワークを用いて、登録処理を行うことの出来る画面を作成。その後、バッチファイルを作成しcsvファイルデータを自動的にDBへ取り込むところまで実施します。 手順 全体手順としては以下の流れで進めます。 デモアプリクローン デモアプリの起動・動作確認 アプリケーションコード修正 バッチファイルコード修正 バッチファイルの動作確認 バッチ処理の自動化 後片付け "},"Section2.html":{"url":"Section2.html","title":"1. デモアプリクローン","keywords":"","body":"デモアプリダウンロード 当手順では以下の赤枠部分を実施します。 Githubリポジトリ表示 以下リンクよりデモアプリのあるGithubリポジトリにアクセスします。 URL:https://github.com/miracleave-ltd/meet-up-26_django ソースコードダウンロード Codeボタンより、Zipファイルをダウンロードします。 ソースコード展開 ダウンロードしたZipファイルを任意のフォルダに展開してください。 ※次の手順を進めるに当たり、展開されたフォルダをVSCodeで開くようお願いします。 サイトを立ち上げてみる デモアプリを修正していない状態で、一度サイトを起動してみましょう。 Dockerの起動 コマンドをVSCodeのターミナル上から実施し、Dockerの起動を行います。 以下イメージのように Creating ... done と表示されると成功です。 docker-compose up -d --build スーパーユーザーの作成 以下コマンドを実施し、管理サイトにて使用するユーザー情報を作成します。 docker-compose run web python manage.py createsuperuser 設定する値はそれぞれ以下の通りです。 ユーザー名：admin メールアドレス：未設定（そのままEnter） パスワード：任意の値（単純すぎるものは警告が出ます） 上記までの手順で、ブラウザに以下URLを入力することで画面を参照することが出来ます。 http://localhost:7777 "},"Section3.html":{"url":"Section3.html","title":"2. アプリケーションコード修正を行う前に","keywords":"","body":"アプリケーションコード修正を行う前に デモアプリの中身について説明します。 前提 その1 本日実装いただく以下の登録画面についてですが、現在は登録ボタンを押してもエラーとなり、 動作しない状態となっていますので、正常に動作するように修正いただきつつ、途中ポイントの説明をさせていただきます。 商品情報登録画面 前提 その2 今回使用するモデルの内容は、それぞれ以下の通りです。 商品名称などを保持、また商品に紐づく画像を保持する2テーブルを準備しております。 app\\product\\models\\product.py from django.db import models class Product(models.Model): code = models.CharField(max_length=3, verbose_name='商品コード', primary_key=True, db_index=True) name = models.CharField(max_length=100, verbose_name='商品名') explanation = models.CharField(max_length=300, verbose_name='商品説明') price = models.IntegerField(default=0, verbose_name='商品価格') create_at = models.DateTimeField(auto_now_add=True, verbose_name='作成日時') update_at = models.DateTimeField(auto_now=True, verbose_name='更新日時') create_user = models.CharField(max_length=10, verbose_name='作成者', blank=True, null=True) update_user = models.CharField(max_length=10, verbose_name='更新者', blank=True, null=True) app\\product\\models\\image.py from django.db import models class Image(models.Model): product = models.ForeignKey('product.product', on_delete=models.SET_NULL, related_name='r_prdct_img', verbose_name='商品情報', blank=True, null=True) image = models.ImageField(upload_to='images/', verbose_name='商品画像', blank=True, null=True) ポイント ForeignKeyとは、異なるテーブルに対して設定し「1対多」の親子関係を持たせることの出来るDjangoの機能です。 今回事前に用意した2テーブルについてもProductを親、Imageを子としてForeignKeyを設定しています。 Productテーブル 商品コード 商品名 ・・・ 10 PC ・・・ 11 マウス ・・・ 12 キーボード ・・・ Imageテーブル ID 商品情報(ForeignKey) 商品画像 1 10 画像1-1 2 10 画像1-2 3 11 画像2 4 12 画像3 ForeignKeyを設定することで、親子テーブル間で以下のようなデータ取得が可能となります。 〇 Image(子)に紐づくProduct(親)の取得 image = Image.objects.get(id=1) product = image.product 〇Product(親)に紐づくImage(子)の取得 product = Product.objects.get(code=10) images = product.r_prdct_img.all() for image in images: # 任意の処理 〇Product情報を元にImageの絞り込み hoge = Product.objects.get(code=10) images = Image.objects.filter(product=hoge) 前提 その3 イチからプロジェクトを作成する場合は、以下手順を実施する必要があります。 デモアプリでは実施済みの状態ですので、当手順自体はスキップしてください。 コマンド django-admin.py startproject config . コマンド python manage.py startapp app コマンド cd app コマンド python ../manage.py startapp product config\\settings.py import os # 一部省略 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] # 一部省略 LANGUAGE_CODE = 'ja' TIME_ZONE = 'Asia/Tokyo' # 一部省略 STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'statics') ] STATIC_ROOT = os.path.join(BASE_DIR, 'static') STATIC_URL = '/static/' app\\product\\apps.py name = 'app.product' "},"Section4.html":{"url":"Section4.html","title":"3. アプリケーションコード修正（商品情報登録画面）","keywords":"","body":"アプリケーションコード修正（商品情報登録画面） 当手順では以下赤枠部分の商品登録画面のコードを修正していきます。 当画面に関連するソースファイル app\\product\\views\\product_create_view.py ←修正対象 app\\product\\urls.py ←修正対象 templates\\product\\product_create.html 修正する前に一度、状況を確認してみましょう。 http://localhost:7777 登録画面、機能が実装できていないことが確認できたかと思います。 確認できたところで、あらためて修正をすすめていきましょう！ Viewの修正 画面からボタンを押下した際に、画面に入力した値をDBへ登録する処理を実装します。 app\\product\\views\\product_create_view.py from app.product.forms.product_create_forms import ProductCreateForm from app.product.models.product import Product from django.urls import reverse_lazy from django.views.generic import CreateView class CreateProductView(CreateView): model = Product form_class = ProductCreateForm template_name = 'product/product_create.html' success_url = reverse_lazy('product:product_create') urls.pyの修正 app\\product\\urls.py に登録画面用のviewをインポートし、 urlpatternsに登録画面へ遷移する為のURL文字列とインポートしたviewを設定します。 app\\product\\urls.py 変更前 from django.urls import path from app.product.views.product_update_view import ProductUpdateView ・・・ path('create/', TemplateView.as_view(template_name='product/product_create.html'), name='product_create'), 変更後 from django.urls import path from app.product.views.product_create_view import CreateProductView # 以下importを追加 from app.product.views.product_update_view import ProductUpdateView ・・・ # 元の文と差し替え path('create/', CreateProductView.as_view(), name='product_create'), ポイント WEBサイトの多くは DBからの情報を絞り込んで検索結果を表示する 検索結果の内、単一の情報の詳細内容を表示する 画面に入力された内容を元にDBへ情報を登録・更新する という機能を持っています。 上記のような定型的な処理について、同じようなコードを書かなくても済むようあらかじめDjangoに処理が定義されています。 その処理のことを汎用ビューと呼び、関数で定義されていれば「関数ベース汎用ビュー」、クラスで定義されていれば「クラスベース汎用ビュー」と呼びます。 クラスベース汎用ビューの内、何点かピックアップして紹介します。 DetailView 個別詳細ページ実装時に使用する汎用ビューとなります。 modelに定義されたテーブルより、URLに指定されたプライマリーキーを元に絞り込まれたレコードを1件取得します。 ※今回配布させて頂いている資材のapp\\product\\views\\product_detail_view.py がDetailViewを使用している画面となりますので、併せてご確認ください views.py from django.views.generic import DetailView from mymodel.model import MyModel class MyDetailView(DetailView): model = MyModel urls.py urlpatterns = [ path('', MyDetailView.as_view()), ] CreateView／UpdateView CreateViewは、新たにレコード追加するフォームを定義することが出来るビューとなります。 UpdateViewは、すでに存在するデータを更新するフォームを定義することが出来るビューとなります。 form_valid , form_invalidというメソッドが定義されているので、エラーの有無によって独自の処理を実施することが可能です。 ※今回配布させて頂いている資材のapp\\product\\views\\product_update_view.py がUpdateViewを使用している画面となりますので、併せてご確認ください views.py from django.views.generic import CreateView from mymodel.model import MyModel from forms import MyModelForm class MyCreateView(CreateView): model = MyModel form_class = MyModelForm def form_valid(self, form): ''' 入力内容チェックにエラーがない場合 ''' messages.success(self.request, \"保存しました\") return super().form_valid(form) def form_invalid(self, form): ''' 入力内容チェックにエラーがある場合 ''' message.warning(self.request, \"保存できませんでした\") return super().form_invalid(form) forms.py from django import forms from mymodel.model import MyModel class MyModelForm(forms.ModelForm): class Meta: model = MyModel exclude = ['create_at', 'update_at', 'create_user', 'update_user',] urls.py urlpatterns = [ path('create/', MyCreateView.as_view()), ] 画面確認 以下URLをブラウザにて入力し画面を表示します。 http://localhost:7777 商品登録情報ボタンを押下してみてください。 登録画面が表示されレイアウトがイメージの通り変更されていれば成功です。このままデータの登録もしてみましょう。 無事登録出来たら、このまま管理画面（Django管理サイト）に移動して実際に登録されているかも併せて見てみましょう。 このとき、usernameとpasswordを求められますが、これは先程createsuperuserで設定したusernameとpasswordでログインすることが出来ます。 "},"Section5.html":{"url":"Section5.html","title":"4. カスタムコマンド","keywords":"","body":"カスタムコマンド（CustomCommands） 当手順では以下の赤枠部分を実施します。カスタムコマンドについてご説明致します。 ここでは、カスタムコマンド（CustomCommands）の実装方法、オプションとして引数を与える場合の記述例などを一通りお話しさせていただいた後、 次のセクションで、未実装となっている以下のバッチファイルのソースコードを修正しつつ、簡単な選択問題に答えていただいて実装していただければと思います。 /meetup/app/batch/management/commands/product_data.py /meetup/app/batch/batches/product_import.py 問題については回答も用意しておりますので、ぜひトライしてみましょう！ CustomCommandsの実装方法 カスタムコマンドは標準でDjangoが持っている機能なので、特別なライブラリをインストールする必要などはありません。 通常のアプリケーションを作成する手順通りコマンドを実行しますが、今回はすでにbatchアプリが作成されているため、そこに新たにbatchファイルを作成していきましょう。 docker-compose exec web touch ./app/batch/management/commands/product_test.py product_test.pyに以下のように記載します /meetup/app/batch/management/commands/product_test.py from django.core.management.base import BaseCommand class Command(BaseCommand): def handle(self, *args, **options): print(\"batch test\") これでバッチが動く状態となります。 以下のコマンドを実施してみましょう。 docker-compose exec web python manage.py product_test 実行することで以下のように出力されます。 batch test では、実際にバッチを動かせたところで、カスタムコマンドを最低限実装するにあたり, 気をつけるポイントが２つあります。 ひとつは、BaseCommandをインポートし、実装するファイル内でBaseCommandを継承した、Commandクラスを定義すること。 もう一つは、定義したクラス内で「handle」という関数を継承させることです。 このhandler関数内に必要な処理を記載することで先程のようにカスタムコマンドを認識し、処理を実行できるようになります。 また、例えば「コマンドへ引数を渡すようにしたい。」というような際は、以下のように 「add_arguments」関数の記載を加えて、「handle」関数側で「options」からそれぞれの値を取り出すことで、コマンドへ引数を渡すことができます。 /meetup/app/batch/management/commands/product_test.py from django.core.management.base import BaseCommand class Command(BaseCommand): def add_arguments(self, parser): parser.add_argument('-a', '--appname', required=True, type=str) parser.add_argument('-d', '--description', required=True, type=str) def handle(self, *args, **options): appname = options['appname'] description = options['description'] print(f'appname={appname} , description={description}') こちらの実装内容ですと、引数「appname」と「description」を必須指定としており、実行する際は以下のように入力する必要があります。 docker-compose exec web python manage.py product_test --appname batch --description producttest 実行することで以下のように出力されます。 appname=batch, description=producttest より詳しい内容を知りたい方は公式を参考にしていただければと思います。 https://docs.djangoproject.com/en/4.0/howto/custom-management-commands/ では、次からコード修正と問題の方に移っていきます。 "},"Section6.html":{"url":"Section6.html","title":"5. batchファイル修正 -問題-","keywords":"","body":"batchファイル修正 -問題- 先程のセクションでご説明させていただいた、未実装となっている２つのファイルを修正していただきたいと思います。 /meetup/app/batch/management/commands/product_data.py /meetup/app/batch/batches/product_import.py また、こちらのバッチでの内容について簡単ですが触れておきたいと思います。 今回修正いただくバッチは、data.csvというcsvファイルに記載してあるデータで商品登録を行うバッチです。 data.csvを覗いてみましょう。 書いてある内容は、１行目には登録するデータのカラム、２・３行目には商品登録時に必要な各カラムのデータになります。 以降の修正が終わった後、バッチ実行後にこちらの内容が登録していることを確認してみましょう。 code,name,explanation,price,create_user,update_user 2,orange,mamde in japan,500,999,999 3,computer,mac,5000,999,999 product_data.py（コード修正） では、まずコードの修正から着手したいと思います。 現在、product_data.pyにはコードが記載されていないため、バッチが起動できません。 以下のコードを反映させて、起動できる状態に修正して下さい。 from django.core.management.base import BaseCommand from app.batch.bathes.product_import import main class Command(BaseCommand): def handle(self, *args, **options): main() これでバッチファイルが起動できるようになりますが、呼び出している処理先のproduct_import.pyも修正する必要があります。 そちらに関しては、以下の問題の回答を反映させて修正をして下さい。 問題 対象ファイル：product_import.py Question１ １．バッチが読み込む対象のファイルを設定してあげましょう。(対象行：L23) FILE_NAMEの変数に設定するパスをいずれかから１つの組み合わせを選んで下さい。 ヒント：os.path.joinメソッドは引数に渡した文字列を結合することで１つのパスにすることが出来ます。 # example path = os.path.join('config', 'settings.py') # path => config/settings.py ① a: 'data', b:'csv' ② a: '/meetup/csv/', b:'data.csv' ③ a: 'csv', b:'data.csv' Question2 ２．対象データを処理するためにimportの記述が必要です。(対象行：L8) 必要な記述はどちらでしょうか？ ヒント：登録画面で作成したモデルを使用します。 ① from app.product.models.product import Product ② from app.product.models.product import Image "},"Section7.html":{"url":"Section7.html","title":"6. batchファイル修正 -回答-","keywords":"","body":"batchファイル修正 -回答- こちらは先程の問題の回答になります。 以下のように修正するとバッチが起動して正常にデータを取り込めるようになります。 修正できたら、以下のコマンドを実行します。 docker-compose exec web python manage.py product_data 修正箇所がすべて解消できていれば、現在以下の内容がターミナルに出力されていると思います。 ※日付、登録データの内容は割愛しています。 商品データ登録 - INFO - == batch処理開始 == 商品データ登録 - INFO - base_dir = /meetup/app/batch/bathes 商品データ登録 - INFO - db_path = /meetup/app/batch/bathes/db.sqlite3 商品データ登録 - INFO - === > Start DB登録 == 商品データ登録 - DEBUG - add_data = {......} 商品データ登録 - DEBUG - add_data = {......} 商品データ登録 - INFO - === > End DB登録 == 商品データ登録 - INFO - == batch処理終了 == 回答 Question１ 正.③ django側で設定している、BASE_DIRはプロジェクトルートを指しています。 そのため、os.path.joinメソッドでは、「プロジェクトルート」から対象ファイルまでのパスとして設定します。 FILE_NAME = os.path.join(BASE_DIR, 'csv', 'data.csv') Question2 正.① 今回操作するモデルオブジェクトは「Product」のため、必要な記述は①です。 カスタムコマンドにより、Djangoの機能を利用すること出来るため、 従来のDjangoと遜色なくModelオブジェクトを操作することが出来ます。 from app.product.models.product import Product "},"Section8.html":{"url":"Section8.html","title":"7. 自動化処理の実装 -incron-","keywords":"","body":"自動化処理の実装 -incron- 当手順では以下の赤枠部分のバッチの自動化についてご説明致します。 自動化にあたり バッチを自動で定期的に実行するために、ジョブ管理ツールや運用管理ソフトを導入したり、Linuxではcron、atなどのジョブスケジューラを検討するかと思います。 今回のハンズオンでは、自動化されている様子をすぐに確認していただくために、「incron」を使用したいと思います。 incron　については本ハンズオンから少し外れた領域のため、詳細の説明は割愛させていただきますが、興味のある方はぜひ一度調べてみて下さい。 incronとは \"inotify cron\"システム。デーモンとテーブルマニピュレーターから構成されており、cronと同じように使用する事が可能。大きな違いとして、cronは期間や日時などのイベントで処理するデーモンに対し、incronはファイルシステムのイベントで処理されます。 Incronの設定・起動 ここからはコンテナ内で作業する必要があります。以下のコマンドを実行して下さい。 docker-compose exec web bash コンテナに入れたら、以下のmakeコマンドを実行して下さい。 make incron-set 続けて、以下のコマンドを実行して下さい。 cd ./csv service incron start && incrontab -d ここまで実行することで、 \"/meetup/csv/フォルダに\"、\"ファイルが移動されてきたら\"、\"/meetup/sh/product.sh\" を実行し、\"/meetup/logs/batch.log\" というログファイルを出力する設定が完了しました。 makefileに上記設定について記載していますので、makefileを覗いてみましょう。 incron-set: echo \"root\" > /etc/incron.allow incrontab -l | { cat; echo '/meetup/csv/ IN_MOVED_TO /bin/sh /meetup/sh/product.sh >& /meetup/logs/batch.log'; } | incrontab - echo \"root\" > /etc/incron.allow こちらでは、incron.allowに許可するユーザーを記載しています。 （今回は\"root\"としていますが、実運用では適切なユーザーを設定して下さい。） incrontab -l | { cat; echo '/meetup/csv/... こちらの内容では「incrontab」へ 監視する対象（/meetup/csv/） 監視するイベント(IN_MOVED_TO) 実行する処理(/bin/sh /meetup/sh/product.sh >& /meetup/logs/batch.log) 以上を入力しています。 それでは、実際に自動でバッチファイルが実行され、DBに登録されるかをみていきたいと思います。 data.csvの修正 /meetup/csv/data.csvを以下のフォルダに一旦移動させます。 mv /meetup/csv/data.csv /meetup/taihi/ 次にdata.csvを修正します。 先程のセクションでバッチを起動しているので、3つのデータが登録されています。 このあとの自動処理後に、反映されたデータがすぐわかるよう、データ数が増えるように修正しましょう。 修正前 code,name,explanation,price,create_user,update_user 2,orange,mamde in japan,500,999,999 3,computer,mac,5000,999,999 修正後 code,name,explanation,price,create_user,update_user 4,pen,mamde in japan,100,999,999 5,bicycle,mamde in germany,35000,999,999 それでは、準備が整いましたので、以下のコマンドを入力して下さい。 mv /meetup/taihi/data.csv /meetup/csv/ 移動できたらadmin画面からデータが登録されているか確認してみましょう！ また、ログファイルにも内容が出力されているので、そちらも併せて確認しましょう！ 登録されていれば成功です！ http://localhost:7777/admin/product/product/ "},"Section9.html":{"url":"Section9.html","title":"8. 構築環境の掃除","keywords":"","body":"local環境のCleanup 当手順では以下の赤枠部分を実施します。 コンテナの停止 次のコマンドを実行し、コンテナの状態を確認します。 docker ps # CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 880cca39ce25 meetup_web \"python3 manage.py r…\" 3 minutes ago Up 3 minutes 0.0.0.0:8000->8000/tcp, :::8000->8000/tcp meetup_web_1 上記で確認できたCONTAINER IDを次のコマンドで利用し、コンテナを停止します。 docker stop [CONTAINER ID] もう一度確認すると、コンテナは削除されていることが確認できると思います。 docker ps # CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES イメージの削除 次のコマンドを実行し、作成したコンテナイメージを確認します。 docker images # REPOSITORY TAG IMAGE ID CREATED SIZE # meetup_web latest 3fb5e3117d67 10 minutes ago 382MB 上記で確認できたIMAGE IDを利用して、ビルドされたイメージを削除します。 docker rmi -f [IMAGE ID] 次のようなメッセージが確認できたら、イメージが正常に削除出来ています。 Untagged: meetup_web... フォルダの削除 最後にフォルダを削除します。 Macの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 ls # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rm -rf xxxxxxxxx Windowsの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 dir # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rd /s /q xxxxxxxxxx # PowerShellをご使用の方はこちらのコマンドをご使用下さい Remove-Item xxxxxxxxxx -Recurse -Force 以上。 これでハンズオンは終了になります。みなさんお疲れさまでした！ "}}